name: Daily Progress Log

on:
  schedule:
    - cron: "30 20 * * *"   # 22:30 Berlin (20:30 UTC)
  push:
    branches: [ main ]      # also run whenever main gets new commits
  workflow_dispatch:
    inputs:
      dedication:
        description: "Dedication (1–10)"
        required: false
      comprehension:
        description: "Comprehension (1–10)"
        required: false
      resilience:
        description: "Resilience (1–10)"
        required: false

permissions:
  contents: write
  pull-requests: write

# Prevent overlapping runs from writing the row twice
concurrency:
  group: progress-${{ github.ref }}
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    env:
      TZ: Europe/Berlin
      # Only count files/commits touching these paths (regex, beginning-anchored).
      # Tune to your repo structure; empty string means "count everything".
      PROGRESS_FILTER_PATH: '^(src|scripts|app|components)/'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      # 1) Compute the Berlin day window and a human date string
      - name: Compute today's window (Berlin)
        id: window
        run: |
          since="$(date -d 'today 00:00' +'%Y-%m-%d %H:%M:%S %z')"
          until="$(date -d 'tomorrow 00:00' +'%Y-%m-%d %H:%M:%S %z')"
          echo "since=$since"  >> $GITHUB_OUTPUT
          echo "until=$until"  >> $GITHUB_OUTPUT
          echo "date=$(date +%Y-%m-%d)" >> $GITHUB_OUTPUT

      # 1.5) Compute today's range on main by merge time (Berlin day)
      - name: Compute today's commit range
        id: range
        run: |
          SINCE="${{ steps.window.outputs.since }}"
          # commit on main immediately before today's Berlin midnight
          base="$(git rev-list -1 --before="$SINCE" origin/main || git rev-list -1 --before="$SINCE" main || true)"
          if [ -z "$base" ]; then
            # repo might be very new—count everything up to HEAD
            echo "range=HEAD" >> $GITHUB_OUTPUT
          else
            echo "range=$base..HEAD" >> $GITHUB_OUTPUT
          fi

      # 2) Gather commits, apply path filter + skip-progress, then compute files/lines for filtered range
      - name: Calculate stats (path-filtered, skip-progress aware)
        id: stats
        shell: bash
        run: |
          set -euo pipefail
          RANGE="${{ steps.range.outputs.range }}"
          FILTER="${PROGRESS_FILTER_PATH:-}"

          # Get log lines within the computed range: <SHA>\t<subject>
          mapfile -t LOG < <(git log $RANGE --no-merges --pretty=$'%H\t%s')

          included_shas=()
          titles=""

          for row in "${LOG[@]:-}"; do
            sha="${row%%$'\t'*}"
            subj="${row#*$'\t'}"
            lcsubj="$(printf '%s' "$subj" | tr '[:upper:]' '[:lower:]')"

            # opt-out: skip-progress in commit title
            [[ "$lcsubj" =~ skip-progress ]] && continue

            # if a path filter is set, only include commits that touched filtered paths
            if [[ -n "$FILTER" ]]; then
              if ! git diff-tree --no-commit-id --name-only -r "$sha" | grep -E -q "$FILTER"; then
                continue
              fi
            fi

            included_shas+=("$sha")
            titles+="$lcsubj"$'\n'
          done

          COMMITS="${#included_shas[@]}"

          # Determine diff range for files/line counts based on the first/last included commit
          DIFF_RANGE=""
          if (( COMMITS > 0 )); then
            FIRST="${included_shas[-1]}"
            LAST="${included_shas[0]}"
            if PARENT=$(git rev-parse "$FIRST^" 2>/dev/null); then
              DIFF_RANGE="$PARENT..$LAST"
            else
              DIFF_RANGE="$LAST"
            fi
          fi

          # Count files/plus/minus in the filtered diff range (excluding PROGRESS.md)
          files=0; plus=0; minus=0
          if [[ -n "$DIFF_RANGE" ]]; then
            # Files changed
            if [[ -n "$FILTER" ]]; then
              files=$(git diff --name-only $DIFF_RANGE | grep -v '^PROGRESS.md$' | grep -E "$FILTER" | sort -u | wc -l | tr -d ' ')
            else
              files=$(git diff --name-only $DIFF_RANGE | grep -v '^PROGRESS.md$' | sort -u | wc -l | tr -d ' ')
            fi

            # Lines +/-
            if [[ -n "$FILTER" ]]; then
              # numstat: "<adds>\t<dels>\t<path>"
              read plus minus < <(git diff --numstat $DIFF_RANGE \
                | grep -v $'\t''PROGRESS.md$' \
                | awk -v re="$FILTER" '$3 ~ re {a+=$1; b+=$2} END{print (a+0), (b+0)}')
            else
              read plus minus < <(git diff --numstat $DIFF_RANGE \
                | grep -v $'\t''PROGRESS.md$' \
                | awk '{a+=$1; b+=$2} END{print (a+0), (b+0)}')
            fi
          fi

          echo "commits=$COMMITS" >> $GITHUB_OUTPUT
          echo "files=$files"     >> $GITHUB_OUTPUT
          echo "plus=$plus"       >> $GITHUB_OUTPUT
          echo "minus=$minus"     >> $GITHUB_OUTPUT

          # Cache titles for next step (Built/Fixed/Next derivation)
          printf '%s' "$titles" > titles.txt

      # 3) Derive Built / Fixed / Next from titles of included commits
      - name: Derive Built/Fixed/Next from titles
        id: bfnt
        run: |
          titles="$(cat titles.txt 2>/dev/null || true)"
          built=$(printf "%s\n" "$titles" | grep -E '^(build:|feat:|refactor:)' | wc -l | tr -d ' ')
          fixed=$(printf "%s\n" "$titles" | grep -E '^fix:' | wc -l | tr -d ' ')
          next=$(printf "%s\n" "$titles" | grep -E '^(next:|chore\(next\):)' | wc -l | tr -d ' ')
          echo "built=$built" >> $GITHUB_OUTPUT
          echo "fixed=$fixed" >> $GITHUB_OUTPUT
          echo "next=$next"   >> $GITHUB_OUTPUT

      # 3.5) Auto-score D/C/R from today's stats (used if you don't type values)
      - name: Auto-score ratings (fallback)
        id: autoscore
        run: |
          COMM="${{ steps.stats.outputs.commits }}"
          FILES="${{ steps.stats.outputs.files }}"
          PLUS="${{ steps.stats.outputs.plus }}"
          MINUS="${{ steps.stats.outputs.minus }}"
          BUILT="${{ steps.bfnt.outputs.built }}"
          FIXED="${{ steps.bfnt.outputs.fixed }}"

          d=$(awk -v c="$COMM" -v f="$FILES" 'BEGIN{v=3+0.4*c+0.3*f; if(v<1)v=1; if(v>10)v=10; printf("%.0f", v)}')
          comp=$(awk -v b="$BUILT" -v x="$FIXED" 'BEGIN{v=6+1.5*(b-x); if(v<1)v=1; if(v>10)v=10; printf("%.0f", v)}')
          res=$(awk -v del="$MINUS" -v fx="$FIXED" 'BEGIN{v=5+0.02*del+0.5*fx; if(v<1)v=1; if(v>10)v=10; printf("%.0f", v)}')

          echo "dedication_auto=$d"       >> $GITHUB_OUTPUT
          echo "comprehension_auto=$comp" >> $GITHUB_OUTPUT
          echo "resilience_auto=$res"     >> $GITHUB_OUTPUT

      # 4) Capture ratings; if blank, use autoscore
      - name: Capture manual ratings (optional)
        id: ratings
        run: |
          d="${{ github.event.inputs.dedication }}"
          c="${{ github.event.inputs.comprehension }}"
          r="${{ github.event.inputs.resilience }}"
          [ -z "$d" ] && d="${{ steps.autoscore.outputs.dedication_auto }}"
          [ -z "$c" ] && c="${{ steps.autoscore.outputs.comprehension_auto }}"
          [ -z "$r" ] && r="${{ steps.autoscore.outputs.resilience_auto }}"
          echo "dedication=$d"    >> $GITHUB_OUTPUT
          echo "comprehension=$c" >> $GITHUB_OUTPUT
          echo "resilience=$r"    >> $GITHUB_OUTPUT

      # 5) Update/append today's row in PROGRESS.md (replace whole line if exists)
      - name: Update PROGRESS.md (Berlin-aware)
        run: |
          DATE="${{ steps.window.outputs.date }}"
          COMM="${{ steps.stats.outputs.commits }}"
          FILES="${{ steps.stats.outputs.files }}"
          PLUS="${{ steps.stats.outputs.plus }}"
          MINUS="${{ steps.stats.outputs.minus }}"
          BUILT="${{ steps.bfnt.outputs.built }}"
          FIXED="${{ steps.bfnt.outputs.fixed }}"
          NEXT="${{ steps.bfnt.outputs.next }}"
          DEDI="${{ steps.ratings.outputs.dedication }}"
          COMP="${{ steps.ratings.outputs.comprehension }}"
          RESI="${{ steps.ratings.outputs.resilience }}"

          NEWROW="| ${DATE} | ${COMM} | ${FILES} | +${PLUS}/-${MINUS} | ${BUILT} | ${FIXED} | ${NEXT} | ${DEDI} | ${COMP} | ${RESI} |"

          if grep -qE "^\|[ ]*${DATE}[ ]*\|" PROGRESS.md; then
            tmp="$(mktemp)"
            awk -v d="$DATE" -v r="$NEWROW" '
              $0 ~ "^\\|[ ]*" d "[ ]*\\|" { print r; next }
              { print }
            ' PROGRESS.md > "$tmp" && mv "$tmp" PROGRESS.md
          else
            printf "\n%s\n" "$NEWROW" >> PROGRESS.md
          fi

      # 6) Open a PR with the change
      - name: Create PR
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore(progress): auto-update"
          title: "chore(progress): auto-update"
          body: "Daily progress log update."
          branch: "progress-bot/update"
          delete-branch: true
          author: "github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"

      - name: Auto-merge PR
        if: steps.cpr.outputs.pull-request-number
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          pull-request-number: ${{ steps.cpr.outputs.pull-request-number }}
          merge-method: squash
